const Mechanic = require('../models/Mechanic');
const Order = require('../models/Order');
const express = require('express');
const app = express();
const mongoose = require('mongoose')
const ObjectId = mongoose.Types.ObjectId;
const diffMinutes = require('../HandleFunction/DiffMinutes')
const handleErr = require('../HandleFunction/HandleErr');
const handleSuccess = require('../HandleFunction/handleSuccess');
const sendNotification = require('../HandleFunction/SendNotification');
const fs = require('fs');
const upload = require('../HandleFunction/UploadFile');
const deleteFile = require('../HandleFunction/DeleteFile')
const refreshTokens = require('../HandleFunction/JWT').refreshTokens;
const refreshTokenKey = require('../constants/jwtpasswords').refreshTokenKey;
const accessTokenKey = require('../constants/jwtpasswords').accessTokenKey;
const auth = require('../HandleFunction/JWT').auth;
const verifyToken = require('../HandleFunction/JWT').verifyToken;

const addDays = function (days) {
  var date = new Date();
  date.setDate(date.getDate() + days);
  return date;
};

const subtractDays = function (days) {
  var date = new Date();
  date.setDate(date.getDate() - days);
  return date;
};

//Register Mechanic
app.post('/api/registerMechanic', (req, res) => {
  let data = req.body;
  if (data.firebaseUID) {
    Mechanic.create(data, (err, doc) => {
      if (err) return res.json(handleErr(err));
      else {
        return res.json(handleSuccess(doc));
      }
    });
  } else {
    return res.json(handleErr('Mechanic can not be null'));
  }
});

//Complete mechanic profile
app.put('/api/completeProfile', (req, res) => {
  if (req.body.id) {
    let data = req.body;
    data.profileCompleted = true;
    Mechanic.findByIdAndUpdate(data.id, data, { new: true }).exec((err, doc) => {
      if (err) return res.json(handleErr(err));
      else {
        return res.json(handleSuccess(doc));
      }
    });
  } else {
    return res.json(handleErr('Mechanic can not be null'));
  }
});

//Upload Mechanic profile pic
app.post('/api/uploadMechanicProfilePic', upload.single('fileData'), (req, res) => {
  //tested
  //below code will read the data from the upload folder. Multer will automatically upload the file in that folder with an  autogenerated name
  fs.readFile(req.file.path, (err, contents) => {
    if (err) {
      return res.json(handleErr(err));
    } else {
      Mechanic.findByIdAndUpdate(req.body.id, { profilePic: req.file.filename }, { new: true }).exec((error, doc) => {
        if (error) return res.json(handleErr(error));
        else {
          return res.json(handleSuccess(doc));
        }
      });
    }
  });
});

//Upload Certificate File
app.post('/api/uploadCertificateFile', upload.single('fileData'), (req, res) => {
  //tested
  //below code will read the data from the upload folder. Multer will automatically upload the file in that folder with an  autogenerated name
  fs.readFile(req.file.path, (err, contents) => {
    if (err) {
      return res.json(handleErr(err));
    } else {
      let response = {
        filePath: req.file.filename,
      };
      return res.json(handleSuccess(response));
    }
  });
});

//Upadate Mechanic
app.put('/api/updateMechanic', (req, res) => {
  if (req.body.id) {
    let data = req.body;
    Mechanic.findByIdAndUpdate(req.body.id, data, { new: true })
      .populate('memberships')
      .exec((err, doc) => {
        if (err) return res.json(handleErr(err));
        else {
          return res.json(handleSuccess(doc));
        }
      });
  } else {
    return res.json(handleErr('Mechanic can not be null'));
  }
});

//Cancel Membership
app.put('/api/cancelMechanicMemberShip', (req, res) => {
  if (req.body.id) {
    Mechanic.findByIdAndUpdate(req.body.id, {
      $unset: { membership: '', membershipDate: '', memberShipExpiry: '' },
    },
      {
        new: true
      }
    ).populate('reviews.user').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        return res.json(handleSuccess(doc))
      }
    });
  } else {
    return res.json(handleErr('Mechanic can not be null'));
  }
});
//Select Membership
app.put('/api/selectMembership', (req, res) => {
  if (req.body.id) {
    let { membershipType, membership, id } = req.body;
    let days = [30, 90, 365];
    const newDate = addDays(days[membershipType]);
    newDate.setHours(0);
    newDate.setMinutes(0);
    newDate.setSeconds(0);
    newDate.setMilliseconds(0);
    Mechanic.findByIdAndUpdate(
      id,
      {
        membership,
        membershipDate: new Date(),
        memberShipExpiry: newDate,
      },
      { new: true }
    )
      .populate('membership')
      .exec((err, doc) => {
        if (err) return res.json(handleErr(err));
        else {
          return res.json(handleSuccess(doc));
        }
      });
  } else {
    return res.json(handleErr('Mechanic can not be null'));
  }
});

//********Find mechanics*********//

//Search nearby
/*
    Mechanism:
    1. Location.
    2. Check membership
    3. City    
 */
app.post('/api/searchNearbyMechanics', (req, res) => {
  if (req.body.longitude && req.body.latitude && req.body.distance) {
    const date = subtractDays(60)
    Mechanic.find({
      geometry: {
        $nearSphere: {
          $geometry: {
            type: 'Point',
            coordinates: [req.body.longitude, req.body.latitude], //longitude and latitude
          },
          $minDistance: 0,
          $maxDistance: req.body.distance * 1000,
        },
      },
      $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }]
    })
      .limit(10)
      .populate('membership')
      .populate('reviews.user')
      .exec((err, docs) => {
        if (err) return res.json(handleErr(err));
        else return res.json(handleSuccess(docs));
      });
  } else {
    return res.json(handleErr('Location can not be null'))
  }
});

//Filter mechanics
app.post('/api/filterMechanics', (req, res) => {
  if (req.body.longitude !== undefined && req.body.latitude !== undefined && req.body.distance !== undefined && req.body.joined && req.body.mechanicType) {
    let { isOnline, longitude, latitude, distance, joined, mechanicType } = req.body
    const date = subtractDays(60)
    if (isOnline === true) {
      Mechanic.find({
        geometry: {
          $nearSphere: {
            $geometry: {
              type: 'Point',
              coordinates: [longitude, latitude], //longitude and latitude
            },
            $minDistance: 0,
            $maxDistance: distance * 1000,
          },
        },
        $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
        mechanicType: mechanicType,
        isOnline: true
      })
        .limit(10)
        .sort({ createdDate: joined === 'latest' ? -1 : 1 })
        .populate('membership')
        .populate('reviews.user')
        .exec((err, docs) => {
          if (err) return res.json(handleErr(err));
          else return res.json(handleSuccess(docs));
        });
    } else {
      Mechanic.find({
        geometry: {
          $nearSphere: {
            $geometry: {
              type: 'Point',
              coordinates: [longitude, latitude], //longitude and latitude
            },
            $minDistance: 0,
            $maxDistance: distance * 1000,
          },
        },
        $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
        mechanicType: mechanicType,
      })
        .limit(10)
        .sort({ createdDate: joined === 'latest' ? -1 : 1 })
        .populate('membership')
        .populate('reviews.user')
        .exec((err, docs) => {
          if (err) return res.json(handleErr(err));
          else return res.json(handleSuccess(docs));
        });
    }
  } else {
    return res.json(handleErr('Location can not be null'))
  }
})

//Match mechanics
app.post('/api/matchMechanics', (req, res) => {
  if (req.body.longitude && req.body.latitude && req.body.carTag) {
    const date = subtractDays(60)
    Mechanic.find({
      geometry: {
        $nearSphere: {
          $geometry: {
            type: 'Point',
            coordinates: [req.body.longitude, req.body.latitude], //longitude and latitude
          },
          $minDistance: 0,
          $maxDistance: 16093.44,   //10 miles in meters
        },
      },
      $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
      carTags: req.body.carTag
    })
      .limit(10)
      .populate('membership')
      .populate('reviews.user')
      .exec((err, docs) => {
        if (err) return res.json(handleErr(err));
        else return res.json(handleSuccess(docs));
      });
  } else {
    return res.json(handleErr('Location can not be null'))
  }
});

//Web filters
app.post('/api/filterWebMechanics', (req, res) => {
  if (req.body.longitude && req.body.latitude && req.body.carTag && req.body.minDistance && req.body.maxDistance) {
    const date = subtractDays(60)
    if (req.body.isOnline === true) {
      Mechanic.find({
        geometry: {
          $nearSphere: {
            $geometry: {
              type: 'Point',
              coordinates: [req.body.longitude, req.body.latitude], //longitude and latitude
            },
            $minDistance: req.body.minDistance * 1000 * 1.6093,
            $maxDistance: req.body.maxDistance * 1000 * 1.6093,   //10 miles in meters
          },
        },
        $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
        carTags: req.body.carTag,
        isOnline: true
      })
        .limit(10)
        .populate('membership')
        .populate('reviews.user')
        .exec((err, docs) => {
          if (err) return res.json(handleErr(err));
          else return res.json(handleSuccess(docs));
        });
    } else {
      Mechanic.find({
        geometry: {
          $nearSphere: {
            $geometry: {
              type: 'Point',
              coordinates: [req.body.longitude, req.body.latitude], //longitude and latitude
            },
            $minDistance: req.body.minDistance * 1000 * 1.6093,
            $maxDistance: req.body.maxDistance * 1000 * 1.6093
          },
        },
        $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
        carTags: req.body.carTag
      })
        .limit(10)
        .populate('membership')
        .populate('reviews.user')
        .exec((err, docs) => {
          if (err) return res.json(handleErr(err));
          else return res.json(handleSuccess(docs));
        });
    }
  } else {
    return res.json(handleErr('Location can not be null'))
  }
});

//Newly joined
app.post('/api/newlyJoinedMechanics', (req, res) => {
  const date = subtractDays(60)
  Mechanic.find({
    $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }],
  })
    .sort({ createdDate: -1 })
    .limit(10)
    .populate('membership')
    .populate('reviews.user')
    .exec((err, docs) => {
      if (err) return res.json(handleErr(err));
      else return res.json(handleSuccess(docs));
    });
});

//Top rated
app.post('/api/topRatedMechanics', (req, res) => {
  Mechanic.aggregate([
    {
      $unwind: "$reviews"
    },
    {
      $group: {
        _id: '$_id',
        ratingAvg: {
          $avg: "$reviews.rating"
        },
        // "doc":{"$first":"$$ROOT"}       //To add all other fields in aggregate
      }

    },
    // {
    //   $replaceRoot: {                 //To combine both doc and aggregate result
    //     newRoot: { $mergeObjects: [{ averageRating: '$ratingAvg' }, '$doc'] },
    //   },
    // }
  ]).sort({ ratingAvg: -1 }).limit(10).exec((err, docs) => {
    if (err) return res.json(handleErr(err));
    else {
      let ids = docs.map((doc) => doc._id)
      Mechanic.find({
        _id: { $in: ids }
      }).populate('membership')
        .populate('reviews.user').exec((error, mechanics) => {
          if (error) return res.json(handleErr(error))
          else {
            let newData = docs.map((mech) => {
              let index = mechanics.findIndex(x => ObjectId(x._id).toString() === ObjectId(mech._id).toString())
              let data = {
                ...mechanics[index]._doc,
                ratingAvg: mech.ratingAvg
              }
              return data
            })
            return res.json(handleSuccess(newData));
          }
        })
    }
  });
});

//Bulk Mechanics
app.post('/bulkMechanics', (req, res) => {
  let data = req.body.data;
  data.forEach((d) => {
    Mechanic.create(d, (err, doc) => {
      if (err) return res.json(handleErr(err));
    });
  });
  setTimeout(() => {
    res.json(handleSuccess('Done'));
  }, 10000);
});
app.get('/all', (req, res) => {
  Mechanic.find().exec((err, docs) => {
    if (err) return res.json(handleErr(err));
    else {
      console.log('docs->', docs.length);
      return res.json(handleSuccess(docs));
    }
  });
});

//Login
app.put('/api/loginMechanic', (req, res) => {
  if (req.body.email) {
    let { email } = req.body
    Mechanic.findOneAndUpdate({ email }, { isLoggedIn: true }, { new: true }).populate('membership')
      .populate('reviews.user').populate('reviews.order')
      .exec((err, doc) => {
        if (err) return res.json(handleErr(err))
        else {
          return res.json(handleSuccess(doc))
        }
      })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})


/**
 customer 5f8f0a2935a19f368827a731
 mechanic 5f98432d2efbbb7c791c0744
 customerDescription My car is not starting.
 longitude 24.8607
 latitude 67.0011
 vehicle 5f8cd18698137a43a3ab9820
 */
app.post('/api/bulkLocation', (req, res) => {
  Mechanic.find({}).exec((err, docs) => {
    if (err) return res.json(handleErr(err))
    else {
      //Latitude: 24.92376, Longitutde: 67.111249
      let latDifference = 0.000001
      let longDifference = 0.0000001
      let longitutde = 67.111249
      let latitude = 24.92376
      let final = []
      docs.forEach((doc) => {
        longitutde += longDifference
        latitude += latDifference
        let location = {
          type: "Point",
          coordinates: [longitutde, latitude]
        }
        Mechanic.findByIdAndUpdate(doc._id, { $set: { geometry: location } }, { new: true }).exec((errr, mech) => {
          if (errr) return res.json(handleErr(errr))
          else {
            final.push(mech)
          }
        })
      })
      setTimeout(() => {
        return res.json(handleSuccess(final.length))
      }, 15000)
    }
  })
})


//Get a mechanic
app.post('/api/getMechanicData', (req, res) => {
  if (req.body.id) {
    Mechanic.findById(req.body.id).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        if (doc !== null) {
          let oldDate = subtractDays(60)
          if (oldDate < doc.createdDate) {    //Less than 60 days have been passed for mechanic
            Order.find({
              mechanic: req.body.id,
              status: { $in: ["rejected", "completed", "cancelled"] }
            }).populate('customer').populate('mechanic').populate('vehcile').sort({ createdDate: -1 }
            ).exec((err, docs) => {
              if (err) return res.json(handleErr(err))
              else {
                let response = {
                  mechanic: doc,
                  orders: docs
                }
                return res.json(handleSuccess(response))
              }
            })
          }
          else if (oldDate > doc.createdDate) { //More than 60 days have been passed for mechanic
            if (doc.membership !== null && doc.membership!==undefined) {  //If Membership is active
              Order.find({
                mechanic: req.body.id,
                status: { $in: ["rejected", "completed", "cancelled"] }
              }).populate('customer').populate('mechanic').populate('vehcile').sort({ createdDate: -1 }
              ).exec((err, docs) => {
                if (err) return res.json(handleErr(err))
                else {
                  let response = {
                    mechanic: doc,
                    orders: docs
                  }
                  return res.json(handleSuccess(response))
                }
              })
            }
            else { //If Membership is inactive
              return res.json(handleErr('Trial Over. Mechanic must purchase membership'))
            }
          }
        }
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})



//Mechanic Google 
app.post('/api/mechanicGoogle', (req, res) => {
  if (req.body.firebaseUID && req.body.email && req.body.fName && req.body.profilePic) {
    let { fName, firebaseUID, profilePic, email } = req.body
    Mechanic.findOneAndUpdate({
      firebaseUID
    },
      {
        isLoggedIn: true
      }, {
      new: true
    }).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        if (doc !== null) {
          return res.json(handleSuccess(doc))
          
        }
        else {
          let data = {
            firebaseUID,
            fName,
            profilePic,
            email,
            loginMethod: "Google",
            isLoggedIn: true
          }
          Mechanic.create(data, (error, mechanic) => {
            if (error) return res.json(handleErr(error));
            else {
              return res.json(handleSuccess(mechanic));
            }
          });
        }
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//Mechanic Apple 
app.post('/api/mechanicApple', (req, res) => {
  if (req.body.firebaseUID && req.body.email && req.body.fName && req.body.profilePic) {
    let { fName, firebaseUID, profilePic, email } = req.body
    Mechanic.findOneAndUpdate({
      firebaseUID
    },
      {
        isLoggedIn: true
      }, {
      new: true
    }).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        if (doc !== null) {
          return res.json(handleSuccess(doc))
        }
        else {
          let data = {
            firebaseUID,
            fName,
            profilePic,
            email,
            loginMethod: "Apple",
            isLoggedIn: true
          }
          Mechanic.create(data, (error, mechanic) => {
            if (error) return res.json(handleErr(error));
            else {
              return res.json(handleSuccess(mechanic));
            }
          });
        }
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//Add mechanic certificate
app.post('/api/addCertificate', (req, res) => {
  if (req.body.id && req.body.certifcate) {
    let { id, certifcate } = req.body
    Mechanic.findByIdAndUpdate(id, { $push: { certificates: certifcate } }, { new: true })
      .populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
        if (err) return res.json(handleErr(err))
        else {
          return res.json(handleSuccess(doc))
        }
      })
  } else {
    return res.json(handleErr('Mechanic and certificate can not be null'))
  }
})
//Remove a certificate
app.post('/api/removeCertificate', (req, res) => {
  if (req.body.id && req.body.certificateId && req.body.image) {
    let { id, image, certificateId } = req.body
    try {
      deleteFile(image)
      Mechanic.findByIdAndUpdate(id,
        {
          $pull: { certificates: { "_id": certificateId } }
        },
        { new: true }
      ).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
        if (err) return res.json(handleErr(err))
        else {
          return res.json(handleSuccess(doc))
        }
      })
    } catch (error) {
      return res.json(handleErr(error))
    }

  } else {
    return res.json(handleErr('Mechanic and certificate can not be null'))
  }
})

//Mechanic logout route
app.put('/api/mechanicLogout', (req, res) => {
  if (req.body.id) {
    let { id } = req.body
    console.log('logout->', id)
    Mechanic.findByIdAndUpdate(id,
      {
        isLoggedIn: false,
        isOnline: false
      },
      { new: true }
    ).exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        return res.json(handleSuccess(doc))
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//Mechanic Analytics
app.post('/api/mechanicAnalytics', (req, res) => {
  if (req.body.mechanic) {
    let { mechanic } = req.body
    var todayDate = new Date(), weekDate = new Date(), monthDate = new Date();
    weekDate.setTime(todayDate.getTime() - (7 * 24 * 3600000));
    monthDate.setTime(todayDate.getTime() - (30 * 24 * 3600000));
    Order.aggregate([
      { $match: { mechanic: new ObjectId(mechanic) } },
      { $match: { status: { $in: ["cancelled", "completed", "payment"] } } },
      { "$group": { _id: "$status", count: { $sum: 1 }, totalEarning: { $sum: "$serviceFee" } } }
    ]).exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        if (doc.length > 0) {
          let orderCompleted = 0
          let orderCancelled = 0
          let totalEarning = 0
          let ratings = 0
          doc.forEach((order) => {
            if (order._id === 'completed' || order._id === 'payment') {
              orderCompleted += order.count
              totalEarning += order.totalEarning
            } else if (order._id === 'cancelled') {
              orderCancelled = order.count
            }
          })
          let totalOrders = orderCompleted + orderCancelled
          let orderCompletion = orderCompleted / totalOrders * 100
          orderCompletion = orderCompletion.toFixed(2)
          let averageEarning = totalEarning / totalOrders
          //Last 7 days
          Order.aggregate([
            { $match: { mechanic: new ObjectId(mechanic) } },
            { $match: { status: { $in: ["completed", "payment", "cancelled"] } } },
            { $match: { createdDate: { $gte: weekDate } } },
            {
              $group: {
                _id: 0,
                lastWeekEarning: { $sum: "$serviceFee" },
                lastWeekOrders: { $sum: 1 }
              }
            }
          ]).exec((error, weekOrder) => {
            if (error) return res.json(handleErr(error))
            else {
              //Last 30 days
              Order.aggregate([
                { $match: { mechanic: new ObjectId(mechanic) } },
                { $match: { status: { $in: ["completed", "payment", "cancelled"] } } },
                { $match: { createdDate: { $gte: monthDate } } },
                {
                  $group: {
                    _id: 0,
                    lastMonthEarning: { $sum: "$serviceFee" },
                    lastMonthOrders: { $sum: 1 }
                  }
                }
              ]).exec((errror, monthOrder) => {
                if (errror) return res.json(handleErr(errror))
                else {
                  Order.find({ mechanic: mechanic, status: { $in: ['completed', 'payment'] } })
                    .sort({ createdDate: -1 }).limit(1)
                    .exec((errr, latestOrder) => {
                      if (errr) console.log('errrr->', errr)
                      else {
                        // console.log('lastWeek->', weekOrder)
                        // console.log('lastMonth->', monthOrder)
                        // console.log('latest->', latestOrder)
                        // let lastOrderTime = diffMinutes(latestOrder[0].createdDate)
                        Mechanic.findById(mechanic, (errrr, mechanicData) => {
                          if (errrr) return res.json(handleErr(errrr))
                          else {
                            if (mechanicData.reviews.length > 0) {
                              let ratingSum = 0
                              mechanicData.reviews.forEach((rev) => {
                                ratingSum += rev.rating
                              })
                              ratings = ratingSum / mechanicData.reviews.length
                            }
                            /**
                             lastMonth-> [ { _id: 0, lastMonthEarning: 14810, lastMonthOrders: 9 } ]
                             weekOrder-> [ { _id: 0, lastWeekEarning: 14810, lastWeekOrders: 9 } ]
                             */
                            let response = {
                              ratings,
                              lastOrderTime: latestOrder.length > 0 ? diffMinutes(latestOrder[0].createdDate) : 0,
                              totalOrders,
                              averageEarning,
                              orderCompletion,
                              lastWeekEarning: weekOrder.length > 0 ? weekOrder[0].lastWeekEarning : 0,
                              lastMonthEarning: monthOrder.length > 0 ? monthOrder[0].lastMonthEarning : 0,
                              lastWeekOrders: weekOrder.length > 0 ? weekOrder[0].lastWeekOrders : 0,
                              lastMonthOrders: monthOrder.length > 0 ? monthOrder[0].lastMonthOrders : 0,
                              totalEarning
                            }
                            console.log('response->', response)
                            //Remining tasks including analytics for dashboard
                            return res.json(handleSuccess(response))
                          }
                        })
                      }
                    })
                }
              })
            }
          })
        } else {
          return res.json(handleSuccess('No Orders'))
        }
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//Get mechanics
app.post('/api/mechanics:page', (req, res) => {
  var perPage = 20
  var page = req.params.page || 1
  Mechanic.find({}).populate('membership')
    .skip((perPage * page) - perPage).limit(perPage).exec((error, data) => {
      if (error) return res.json(handleErr(error))
      else Mechanic.estimatedDocumentCount({}).exec((err, count) => {
        if (err) return res.json(handleErr(err))
        else {
          let response = {
            data,
            current: page,
            pages: Math.ceil(count / perPage)
          }
          return res.json(handleSuccess(response))
        }
      })
    })
})

//Block Mechanic
app.post('/api/blockMechanic', (req, res) => {
  if (req.body.id) {
    let { id } = req.body
    Mechanic.findByIdAndUpdate(id, {
      blocked: true
    }, {
      new: true
    }).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        //Send notification
        if (doc.token !== undefined && doc.token !== null) {
          let data = {
            tokens: [doc.token],
            body: "Your user account has been blocked by admin.",
            title: "BLOCKED!"
          }
          sendNotification(data)
        }
        return res.json(handleSuccess(doc))
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//Unblock Mechanic
app.post('/api/unblockMechanic', (req, res) => {
  if (req.body.id) {
    let { id } = req.body
    Mechanic.findByIdAndUpdate(id, {
      blocked: false
    }, {
      new: true
    }).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, doc) => {
      if (err) return res.json(handleErr(err))
      else {
        //Send notification
        if (doc.token !== undefined && doc.token !== null) {
          let data = {
            tokens: [doc.token],
            body: "Your user account has been unblocked now. You can continue offering your services.",
            title: "UNBLOCKED!"
          }
          sendNotification(data)
        }
        return res.json(handleSuccess(doc))
      }
    })
  } else {
    return res.json(handleErr('Mechanic can not be null'))
  }
})

//mechanics by city
app.post('/api/getMechanicsByCity', (req, res) => {
  const date = subtractDays(60)
  if (req.body.city) {
    let { city } = req.body
    console.log('city->', city)
    Mechanic.find({
      city,
      $or: [{ membership: { $ne: null } }, { $and: [{ membership: null }, { createdDate: { $gte: date } }] }]
    }).populate('membership').populate('reviews.user').populate('reviews.order').exec((err, docs) => {
      if (err) return res.json(handleErr(err))
      else {
        return res.json(handleSuccess(docs))
      }
    })
  } else {
    return res.json(handleErr('City can not be null'))
  }
})
module.exports = app;
